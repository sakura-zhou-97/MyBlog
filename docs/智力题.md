# 怎样对40亿个8位正整数进行排序

这里可以借鉴快速排序的思想，将整个数据量进行分解，取8位正整数的中间值，凡是大于这个数的值都放入文件b，小于的都放入文件a。

然后再按照这种方法一直分解直到任意一边的数量小于1千万为止，然后使用快速排序对这1千万进行排序，最后将结果存入文件中，然后便不再对该数据集进行处理。

由于内存牵涉到运算的效率和性能，所以，每分解一次，都要将分解的结果放入文件中。


最后就是对这些所有的文件中的结果进行合并，这里可以考虑用一个链表存放所有文件结果集的次序（也是所有排序结果的次序）

所以，总结一下：

1. 使用文件代替以前的数组，对数据按照快速排序的思想进行分解

2. 当某一结果集分解到足够小，比如小于1千万时，此时对该数据运用快速排序，然后将排序结果放入文件中，并且不在对该数据集进行处理

3. 合并所有结果，按照递归的思想，可以使用一个链表记录那些文件存放了结果集，并且是有序的存放的。
你可以定义一个struct结构体，


其他解决方案：

你也可以采用分布式的方法进行运算，但是仍然得对所有数据采用快排的思想的分解。

将原任务不仅要分解成较小的规模，还应该考虑到所有的结果方便组装成为最总的结果 


# 64匹马，8个赛道，最少多少次比赛找出最快的 4 匹马，以及对所有马进行排序



## 问题一：64 匹马，8 个赛道，最少几场比赛找出最快的 4 匹马

问题中隐含的意思：
  1、就是每次比赛马的时间不计，只对比赛的马进行快慢排名，在一次比赛中 A 马 比 B 马快，那就认为它就是比 B 马快。
  2、只需要找出最快的 4 匹马，不需要知道顺序。

从中可以得出淘汰原理：
  1、一匹马 A 在一次比赛中获得名次 n，那他在 64 匹马中最好可能的排名就是 n（因为已知就有 n - 1 匹马比它快）
  2、任意一次比赛，只要排名在第五及以后的马，可以直接淘汰
  3、如果一匹马 A 在一次比赛中获得第四名，那么已知比 A 慢的马可就都可以淘汰了（很有用）

算法步骤分为以下 4 步：

**第一步：淘汰一半，64 进 32（共 8 场比赛）**
第一步就是最正常的八场比赛，每场比赛淘汰后四名，也就是 64 进 32，如下图（灰色就是淘汰了的）。

![在这里插入图片描述](picture/智力题.assets/20190819113848108.png)

值得注意的是，上图中的每一列，从上到下有序排列，列与列之间没有关系，也就是 A8 可能比 B1 还快。

**第二步：每组第一名进行比赛，32 进 10（共 1 场比赛）**
第一步之后淘汰了一半，我们对上边八场比赛的 8 个第一名进行一次比赛，根据上边的淘汰原理3，后四组都可以直接淘汰了，而且，可以淘汰不止后 16 匹。我们将前四组按照第一名在这一轮比赛中的排名进行排序，得到下图（其中 A1 > B1 > C1 > D1，’>’ 就是快的意思）：

<img src="picture/智力题.assets/20190819114045759.png" alt="在这里插入图片描述" style="zoom:50%;" />

可以发现，既然同样根据淘汰原理3，既然 D1 已经比 A1、B1、C1 都慢了，它最好排名就是 64 匹中的第四了，那么 D2、D3、D4 都可以直接淘汰了。同理淘汰 B4、C3、C4。剩下 10 匹。

**第三步：可能可以结束 （共 1 场比赛）**
从上边的图中可以发现，同一列中，靠上的更快，第一行中，靠左的更快，也就是说第一名我们已经知道了，就是 A1，第二只可能是 A2 或者 B1（但已知比 B1 慢的马 B2、B3、C1、C2、D1，比已知比 A2 慢的马 A3、A4 ）。
  剩下的 9 匹马，8 个赛道一次比不出来，那就不让 B1 参加比赛，剩下的 8 匹马进行一次比赛，如果 B2、B3、C1、C2、D1 中的任意一匹马，出现在在这一轮比赛中的前三名，那就把第三名踢掉，B1 和前两名一起，加上 A1 就组成了最快的四匹马，到这里就结束了，也就是总共进行 10 场比赛（这也是为什么选 B1 不参加比赛的原因，因为它已知比它右边、下边、右下边的马都快）。

**第四步：一定结束 （共 1 场比赛）**
如果上边一步没有结束，那就说明，上边一轮的前三名是 A2、A3、A4，那就让 A4 和 B1 两匹马比一下就行了，A4 赢了的话，A 组前四就是总体前四，顺序也确定；B1赢了的话，A1、A2、A3、B1是总体前四，但是 B1 位置不确定（想确定的话，刚刚四匹马一起比赛就行了= =）。
  至此结束，有可能 10 场结束，但所有情况下，最少 11 场。

同理，36 个赛车，6 个跑道，最少 8 次找出前三（情况比这道题还简单，不用分类讨论）。

## 问题二：64 匹马，8 个赛道，最少多少次比赛对所有马进行排序

**第一步：8 场比赛**

![在这里插入图片描述](picture/智力题.assets/20190819114233242.png)

首先还是排成 8 * 8 的方阵，每一列进行一场比赛，并从上到下排序，如上图，每一列从上到下，从快到慢；列与列之间没有关系。这样我们就得到了 8 个第一名（A1、B2、C1 … H1）和 8 个最后一名（A8、B8、C8 … H8），但是我们还是不知道任意一匹马的确定名次。

第二步：循环，每 4 场决出 8 个名次（4 个前边的，4 个倒数的）（共 4 * 7 = 28 场）
我们让 8 个第一名进行一场比赛，8 个最后一名进行一场比赛，就决出了第 1 名和第 64 名，并且把第一行和最后行按照它们的第一名在这一轮中的名次从左到右排序，如下图（每一列的第二行到第七行，依然是从上到下，从快到慢；第一行和最后一行，从左到右，从快到慢），也就是 A1 是总体第一名，H8 是总体倒数第一名：

![在这里插入图片描述](picture/智力题.assets/20190819114320742.png)那么可以看出，现在第二名的候选马就只有 B1 和 A2 了，倒数第二的候选马也只有 G8 和 H7 了。那么我们选 A2、B1、B2、C1 这四匹马以及 H7、G7、G8、F8 这四匹马组成八匹马进行一场比赛，这样我们一定能确定第 2 名和第 63 名。
  因为这一场比赛第一名只可能是 A2 或者 B1（因为其他所有马，已知比它们快的就至少有两匹了，A2 或者 B1 已知只有 A1 比它们俩快），所以分类讨论一下可以得出：第三名、第四名的候选马不超过 4 匹

如果 A2 获胜，第三名的候选马是 A3、B1，第四名的候选马是 A4 以及 B2、C1两个中较快的一个（这两匹在上边的比赛中已经比过了）；
如果 B1 获胜，第三名的候选马就已经知道了，是 A2、B2、C1 三匹马中最快的（也就是为什么要选上边橙色框的四匹马进行比赛）：
如果是 A2 最快，第四名的候选马是 A3 以及 B2、C1 中较快的；
如果是 B2 最快，第四名的候选马是 B3 以及 A2、C1 中较快的；
如果是 C1 最快，第四名的候选马是 A2、B2 中较快的以及 C2、D1。
同理可得，倒数第三倒数第四的候选马，也不超过4匹，那么我们就可以让这些马放在一起，再赛一场，这样就知道第三、第四、倒数第三、倒数第四的是哪些马了，至此，我们就确定了前四名的马和最后四名的马。
  上边一共进行了 4 场比赛，每组第一一场，每组最后一名一场，确定第二、倒数第二一场，确定第三、第四、倒数第三、第四一场，接下来就是重复这个循环，每组（每一列）剩余马中，最快的 8 匹一场，最慢的 8 匹一场，确定没有确定的该排名的马中，最快的和最慢的，接下来两场确定没有确定排名的马中第二、第三、第四、倒数第二、倒数第三、倒数第四（一共  8 个名次）；这样一共循环 7 次，也就是 7 * 4 = 28 场之后，就确定了 7 * 8 = 56 个名次。
1 场比赛，最后 8 匹马

进行上述过程之后，最后还剩 64 - 56 = 8 个名次没有确定，那最后剩下的没有名次的 8 匹马赛一次，就全部都确定了。也就是说，一共进行了 8 + 4 * 7 + 1 = 37 场比赛，确定了所有 64 匹马的名次。

# BitMap

## 1.简介

Bit-map的基本思想就是用一个bit位来标记某个元素对应的Value，而Key即是该元素。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。（PS：划重点 **节省存储空间**）

假设有这样一个需求：在20亿个随机整数中找出某个数m是否存在其中，并假设32位操作系统，4G内存

在Java中，int占4字节，1字节=8位（1 byte = 8 bit）

如果每个数字用int存储，那就是20亿个int，因而占用的空间约为 (2000000000*4/1024/1024/1024)≈**7.45**G

如果按位存储就不一样了，20亿个数就是20亿位，占用空间约为 (2000000000/8/1024/1024/1024)≈**0.233**

### 1.表示

刚才说了，每一位表示一个数，0表示不存在，1表示存在，这正符合二进制

这样我们可以很容易表示{1,2,4,6}这几个数：

<img src="picture/智力题.assets/874963-20190930154945790-1681218156.png" alt="img" style="zoom: 50%;" />

计算机内存分配的最小单位是字节，也就是8位，那如果要表示{12,13,15}怎么办呢？

当然是在另一个8位上表示了：

<img src="picture/智力题.assets/874963-20190930161508728-1545815203.png" alt="img" style="zoom: 50%;" />

这样的话，好像变成一个二维数组了

1个int占32位，那么我们只需要申请一个int数组长度为 int tmp[1+N/32] 即可存储，其中N表示要存储的这些数中的最大值，于是乎：

tmp[0]：可以表示0~31

tmp[1]：可以表示32~63

tmp[2]：可以表示64~95

如此一来，给定任意整数M，那么M/32就得到下标，M%32就知道它在此下标的哪个位置

### 2.添加

这里有个问题，我们怎么把一个数放进去呢？例如，想把5这个数字放进去，怎么做呢？

首先，5/32=0，5%32=5，也是说它应该在tmp[0]的第5个位置，那我们把1向左移动5位，然后按位或

<img src="picture/智力题.assets/874963-20190930170044824-1061422457.png" alt="img" style="zoom:50%;" />

### 3.清除 

还是上面的例子，假设我们要6移除，该怎么做呢？

<img src="picture/智力题.assets/874963-20191013123453790-20308625.png" alt="img" style="zoom: 50%;" />

从图上看，只需将该数所在的位置为0即可

1左移6位，就到达6这个数字所代表的位，然后按位取反，最后与原数按位与，这样就把该位置为0了

### 4.查找 

假设，我们想知道3在不在，那么只需判断 b[0] & (1<<3) 如果这个值是0，则不存在，如果是1，就表示存在

## 2.Bitmap有什么用

> 大量数据的快速排序、查找、去重

### 快速排序

优点：

- 运算效率高，不需要进行比较和移位；
- 占用内存少，比如N=10000000；只需占用内存为N/8=1250000Byte=1.25M

缺点：

- 所有的数据不能重复。即不可对重复的数据进行排序和查找。
- 只有当数据比较密集时才有优势

### 快速去重

20亿个整数中找出不重复的整数的个数，内存不足以容纳这20亿个整数。 

首先，根据“内存空间不足以容纳这05亿个整数”我们可以快速的联想到Bit-map。下边关键的问题就是怎么设计我们的Bit-map来表示这20亿个数字的状态了。其实这个问题很简单，一个数字的状态只有三种，分别为不存在，只有一个，有重复。因此，我们只需要2bits就可以对一个数字的状态进行存储了，假设我们设定一个数字不存在为00，存在一次01，存在两次及其以上为11。那我们大概需要存储空间2G左右。

接下来的任务就是把这20亿个数字放进去（存储），如果对应的状态位为00，则将其变为01，表示存在一次；如果对应的状态位为01，则将其变为11，表示已经有一个了，即出现多次；如果为11，则对应的状态位保持不变，仍表示出现多次。

最后，统计状态位为01的个数，就得到了不重复的数字个数，时间复杂度为O(n)。

### 快速查找

这就是我们前面所说的了，int数组中的一个元素是4字节占32位，那么除以32就知道元素的下标，对32求余数（%32）就知道它在哪一位，如果该位是1，则表示存在。

### 小结&回顾

Bitmap主要用于快速检索关键字状态，通常要求关键字是一个连续的序列（或者关键字是一个连续序列中的大部分）， 最基本的情况，使用1bit表示一个关键字的状态（可标示两种状态），但根据需要也可以使用2bit（表示4种状态），3bit（表示8种状态）。

Bitmap的主要应用场合：表示连续（或接近连续，即大部分会出现）的关键字序列的状态（状态数/关键字个数 越小越好）。

### 问题及应用实例

#### 1.使用位图法判断整形数组是否存在重复

位图法比较适合于这种情况，它的做法是按照集合中最大元素max创建一个长度为max+1的新数组，然后再次扫描原数组，遇到几就给新数组的第几位置上1，如遇到 5就给新数组的第六个元素置1，这样下次再遇到5想置位时发现新数组的第六个元素已经是1了，这说明这次的数据肯定和以前的数据存在着重复。这种给新数组初始化时置零其后置一的做法类似于位图的处理方法故称位图法。

#### 2.在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数

**解法一：**

> 将bit-map扩展一下，采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。

> 或者我们不用2bit来进行表示，我们用两个bit-map即可模拟实现这个2bit-map，都是一样的道理。
>

**解法二：**进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素。

**解法三：**只是划分时按照快排partition一样划分，直到划分到每个块都可以放入内存中。

#### 3.给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？

bitmap算法就好办多了。申请512M的内存，一个bit位代表一个unsigned int值，读入40亿个数，设置相应的bit位；读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。
Note: unsigned int最大数为2^32 - 1，所以需要2^32 - 1个位，也就是(2^32 - 1) / 8 /10 ^ 9G = 0.5G内存。

逆向思维优化：usinged int只有接近43亿（unsigned int最大值为232-1=4294967295,最大不超过43亿），所以可以用某种方式存没有出现过的3亿个数（使用数组{大小为3亿中最大的数/8 bytes}存储），如果出现在3亿个数里面，说明不在40亿里面。3亿个数存储空间一般小于40亿个。（xx存储4294967296需要512MB， 存储294967296只需要35.16MBxx）

#### 4.给定一个数组a，求所有和为SUM的两个数。

如果数组都是整数（负数也可以，将所有数据加上最小的负数x，SUM += 2x就可以了）。如a = [1,2,3,4,7,8]，先求a的补数组[8,7,6,5,2,1]，开辟两个数组b1,b2（最大数组长度为SUM/8/2{因为两数满足和为SUM，一个数<SUM/2，另一个数也就知道了}，这样每个b数组最大内存为SUM/(8*2*1024*1024) = 128M）,使用bitmap算法和数组a分别设置b1b2对应的位为1，b1b2相与就可以得到和为SUM的两个数其中一个数了。

# 两堆苹果，一堆七个，一堆十个，你先拿，谁拿完最后一个就输，问你是必赢，还是必输，还是不确定

最开始两堆苹果不相等时，7，10为例，我先拿走三个，变成7，7。
另一个人无论怎么拿，我都保证两堆相等就可以。

# 1000个球分成五堆，某些堆可以为0，有多少种分法
