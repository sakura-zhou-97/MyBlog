# JVM中使用的优化技术

下面主要看几项最有代表性的优化技术：

- 语言无关的经典优化技术之一：公共子表达式消除
- 语言无关的经典优化技术之一：数组范围检查消除
- 最重要的优化技术之一：方法内联
- 最前沿的优化技术之一：逃逸分析

## 1、公共子表达式消除

公共子表达式消除消除的含义是：**如果一个表达式E已经计算过了，并且从先前的计算到现在E中的所有变量值都没有发生变化，那么E的这次出现就成为了公共子表达式**。对于这种表达式，没有必要花时间再去对它进行计算，只需要直接用前面计算过的表达式结果替代E就可以了。如果这种优化仅限于程序的基本块内，便称为局部公共子表达式消除；如果这种优化的范围涵盖了多个基本块，便称为全局公共子表达式消除。举个简单的例子，假设存在以下代码：

int d = (c * b) * 12 + a + (a + b * c);

如果这段代码交给`Javac编译器`则不会进行任何优化。但是这段代码进入到`虚拟机即时编译器`之后，它将会进行如下优化，编译器检测到"c * b"和"b * c"是一样的表达式，而且在计算期间b与c的值是不变的，因此这条表达式将被视作：

```java
int d = E * 12 + a + (a * E);
```

这时，编译器还可能进行另一种叫做代数简化的优化，把表达式变为：

```java
int d = E * 13 + a * 2;
```

表达式进行变换之后，在计算起来就可以节省一些时间了

## **2、数组范围检查消除**

我们知道Java语言是一门动态安全的语言，对数组的读写访问也不像C、C++那样在本质上是裸指针操作，如果有一个数组foo[]，在Java语言中访问数组元素foo[i]的时候将会自动进行上下界的范围检查，即检查i>=0&&i<foo.length这个条件，否则将会抛出一个数组下标越界异常。这

对开发者来说是一件好事，即使程序员没有专门编写防御代码，也可以避免大部分的溢出攻击，但是对于虚拟机来说，每次数组元素的读写都带有一次隐含的条件判定操作，对于拥有大量数组访问的程序代码，无疑也是一种性能负担。

无论如何，为了安全，数组边界检查肯定是必须做的，但数组边界检查是不是必须在运行期间一次不漏地检查则是可以商量的。比如数组下标是一个常量，只要在编译期间根据数据流分析来确定foo.length的值，并判断下标有没有越界，执行的时候就不需要判断了。

更加常见的情况是数组访问发生在循环之中，并且使用循环变量来进行数组访问，[**[如果编译器只要通过数据流分析尽可以判定循环变量的取值范围永远在区间[0, foo.length)之间]()**]()，那整个循环中就可以把数组的上下界检查消除，这可以节省很多次的条件判断操作。

## **3、方法内联**

最重要的优化手段之一。

它的目的主要有两个：**去除方法调用的成本（如建立栈帧等）、为其他优化建立了良好的基础**，方法内联膨胀之后可以便于在更大范围上采取后续的优化手段。方法内联举个例子：

```java
public final int getA()
{
    getA()语句1;
    getA()语句2;
    getA()语句3;
    getA()语句4;
    getA()语句5
}
```

```java
public static void main(String[] args)
{
    main语句1;
    main语句2;
    int i = getA();
    main语句3;
    main语句4
}
```

优化之后变为：

```java
public static void main(String[] args)
{
    main语句1;
    main语句2;
    getA()语句1;
    getA()语句2;
    getA()语句3;
    getA()语句4;
    getA()语句5;
    main语句3;
    main语句4
}
```

> 从效果上看，无非是把getA()方法中的内容原封不动地拿到main函数中，但这样却[**少了保护现场、恢复线程、建立栈帧**]()等一系列的工作，并且代码一膨胀，原来方法A有5行代码，方法B有6行代码，方法C有7行代码，对于三个方法各自运行来说可能没什么好优化的，但是[**三个方法合起来放到main函数之中，就有了很大的优化空间了**]()(指令重排)。

讲到这里，我们是否理解**为什么要尽量把方法声明为final**？

因为Java有多态的存在，运行时调用的是哪个方法可以根据实际的子类来确定，极大地增强了灵活性，但是这样的话，编译期间同样也无法确定应该使用的是哪个版本，所以无法被内联。**但是被声明为final的方法不一样，这些方法无法被重写，所以调用类A的B方法，运行时调用的必然是类A的B方法，可以被内联**。

## **4、逃逸分析**

目前Java虚拟机中比较前沿的优化技术，[**它并不是直接优化代码的手段，而是为其他优化手段提供了分析技术**]()。

逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中去，称为方法逃逸。甚至可能被外部线程访问到，比如赋值给类变量或可以在其他线程中访问到的实例变量，称为线程逃逸。

如果能证明一个对象不会逃移到方法外或者线程之外，也就是别的方法或线程无法通过任何途径访问到这个对象，则可能为这个变量进行一些高效的优化：

（1）栈上分配

Java虚拟机中，对象在堆上分配这个众所周知。虚拟机的垃圾收集系统可以回收堆中不再使用的对象，但回收动作无论是筛选可回收对象还是回收和整理内存都要耗费时间。

如果确定一个对象不会逃逸出方法之外，那么让这个对象在栈上分配将会是一个不错的主意，对象所占用的内存空间就可以随着栈帧出栈而销毁，这样垃圾收集系统的压力将会小很多

（2）同步消除

线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定不会有颈枕，对这个变量实施的同步措施也就可以消除掉

（3）标量替换

标量是指一个数据已经无法再分解成更小的数据来表示了，Java中的基本数据类型即引用类型都不能进一步分解，因此，它们可以称为标量。相对的，一个数据如果还可以继续分解，那么就称为聚合量，Java中的对象就是最典型的聚合量。如果逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散的话，那程序真正执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。将对象拆分后，除了可以让对象的成员在栈上分配和读写外，还可以为后续进一步的优化手段创建条件。

[**不成熟的原因主要是不能保证逃逸分析的性能收益必定能高于它的消耗。**]()

# Java内存区域

### 栈

栈是运行时的单位，而堆是存储的单位

**设置栈内存大小**

```java
-Xss：设置线程的最大栈空间
```

#### 栈帧

- 局部变量表
- 操作数栈
- 动态链接（指向运行时常量池的方法引用）
- 方法返回地址（方法正常退出或异常退出的定义）
- 一些附加信息（对程序调试提供支持的信息）

![image-20201127195828262](picture/jvm.assets/image-20201127195828262.png)

#### 局部变量表

> [**一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量**]()

注意：

- 由于局部变量表是建立在线程的栈上，是线程私有数据，因此不存在数据安全问题。
- 局部变量表的大小是在编译期确定下来的。在方法运行期间是不会改变局部变量表的大小的。
- 方法嵌套调用的次数由栈的大小决定。但是对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更大的占空间，导致其嵌套调用的次数减少。
- 局部变量表只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。

##### 变量槽（Slot）

- 局部变量表，[**最基本的存储单元是Slot（变量槽）**]()
- 局部变量表里，32位以内的类型只占用一个slot（包括`returnAddress`类型），64位的类型（long和double）占用两个slot
- JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值
- slot是可以复用的，如果一个局部变量过了其作用域，之后申请的局部变量就有可能会复用过期局部变量的槽位，从而节约资源。

<img src="文档笔记/日常学习/复习记录/picture/jvm.assets/image-20201127210749296.png" alt="image-20201127210749296" style="zoom:50%;" />

> 局部变量表（GCRoots）是重要的垃圾回收根节点，只要被局部变量表直接或间接引用的对象都不会被回收

#### 操作数栈

> [**根据字节码指令往栈中写入数据或提取数据，通过入栈，出栈**]()

- 如果被调用的方法由返回值的话，其返回值就会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令

##### 栈顶缓存

操作数存储在内存中，频繁读写必然会影响执行速度。

因此，HotSpot JVM提出了栈顶缓存技术（ToS，Top-of-Stack Cashing）技术，

[**将栈顶元素全部缓存在CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。**]()

#### 动态链接

> [**指向运行时常量池的方法引用**]()

- 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。
- 在java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里。比如一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的。[**那么动态链接的作用就是为了让这些符号引用转换为调用方法的直接引用。**]()

![image-20201127213626886](picture/jvm.assets/image-20201127213626886.png)

- 静态链接：
  - 当一个字节码文件被装载进JVM内部时，如果**被调用的目标方法在编译期可知**，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。
- 动态链接：
  - 如果**被调用的方法在编译器无法被确定下来**，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此被称为动态链接。

#### 方法返回地址

> **存放调用该方法的`pc寄存器`的值，即[调用该方法的指令的下一条指令的地址]()**

- 一个方法的结束由两种方式：
  - 正常执行完成
  - 出现未处理的异常，非正常退出
- 无论通过哪种类型退出，在方法退出后都返回到该方法被调用的位置。
  - 方法正常退出时，返回地址是调用者的PC寄存器的值，即调用该方法的指令的下一条指令的地址
  - 异常退出时，返回地址是通过异常表来确定的，栈帧一般不会保存这部分信息。只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。也就是异常完成出口。![image-20201129145140045](picture/jvm.assets/image-20201129145140045.png)
  - 通过异常完成出口退出的，不会给它的上层调用者产生任何的返回值。
- [**方法的退出本质上就是当前栈帧出栈的过程。**]()此时，需要恢复上层方法的局部变量表，操作数栈，将返回值压入调用者栈帧的操作数栈，设置PC寄存器值等，让调用者继续执行下去。

### 本地方法栈

#### 什么是本地方法

![image-20201129152930138](picture/jvm.assets/image-20201129152930138.png)

![image-20201129152951904](picture/jvm.assets/image-20201129152951904.png)

![image-20201129153026505](picture/jvm.assets/image-20201129153026505.png)

![image-20201129153106334](picture/jvm.assets/image-20201129153106334.png)

![image-20201129153149928](picture/jvm.assets/image-20201129153149928.png)

#### 本地方法栈

> [**Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用**]()

- 本地方法栈也是线程私有的
- ![image-20201129153352946](picture/jvm.assets/image-20201129153352946.png)
- 本地方法是使用C语言实现的
- ![image-20201129153627491](picture/jvm.assets/image-20201129153627491.png)

### 堆

- 几乎所有的对象实例和数组都在运行时分配在堆上
- [**数组和对象永远不会存储在栈上，因为栈帧保存引用，这个引用指向对象或者数组在堆中所在的位置**]()
- 在方法结束后，堆中的对象并不会马上被移除，仅仅在垃圾收集的时候才会被移除 

#### 参数设置

```
-Xms 用于表示堆区的起始内存，等价于-XX:InitialHeapSize （初始为物理电脑内存/54）（年轻代+老年代）
-Xmx 用于表示堆区的最大内存，等价于-XX:MaxHeapSize (最大为物理电脑内存/4)
通常将-Xms和-Xmx设置为相同的值，目的是能够在垃圾回收机制清理完堆区后不需要重新分配计算堆区的大小，从而提高性能
```

```
配置年轻代和老年代的比例：
    默认-XX:NewRatio=2,表示新生代占1，老年代占2
配置Eden和Survivor的比例：
    默认-XX:SurvivorRatio=8，表示Eden占8份，两个Survivor各占1份
设置放入养老区的次数（阈值），默认是15次：
    -XX:MaxTunuringThreshold
```

#### 堆是分配对象存储的唯一选择吗？

![image-20201129192142438](picture/jvm.assets/image-20201129192142438.png)

##### 逃逸分析

> 如果需要将堆上的对象分配到栈上，就需要使用到逃逸分析手段
>
> 逃逸分析是能够分析出一个新的对象的引用的使用范围。
>
> - 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸
> - 当一个对象在方法中被定义后，被外部方法所引用，则发生逃逸。例如作为调用参数传递到其他地方。

通过逃逸分析编译器可以对代码做如下优化：

> 1. [**栈上分配**]()
>
>    将堆分配转化为栈上分配。如果一个对象在子程序中被分配，要使得指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。
>
> 2. [**同步省略**]()
>
>    如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。（`JIT编译器`，即[**锁消除**]()）
>
> 3. [**标量替换**]()
>
>    有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存中，而是存储在CPU寄存器中。

标量替换（大大减少堆内存的占用）

![image-20201129193933046](picture/jvm.assets/image-20201129193933046.png)

![image-20201129193943742](picture/jvm.assets/image-20201129193943742.png)

![image-20201129194032979](picture/jvm.assets/image-20201129194032979.png)

### 方法区

![image-20201129194155492](picture/jvm.assets/image-20201129194155492.png)

> 方法区是各个线程共享的区域，并且内存空间和堆一样都可以是不连续的
>
> 方法区溢出：1.加载大量的第三方jar包（Tomcat工程）     2.大量动态的生成反射类

元空间和永久代类似，都是对方法区的实现。

[**最大的区别在于：元空间不在虚拟机设置的方法区的内存中，而是使用本地内存。**]()

**设置**

```
JDK8及以后
-XX:MetaSpacceSize 设置元空间初始分配空间（默认21）
-XX:MaxMetaSpacceSize 设置元空间最大可分配空间（-1,即没有限制）
```

![image-20201129195231273](picture/jvm.assets/image-20201129195231273.png)

#### 内部结构

![image-20201129195424059](picture/jvm.assets/image-20201129195424059.png)

##### 类型信息

![image-20201129195548658](picture/jvm.assets/image-20201129195548658.png)

##### 域信息

![image-20201129195619792](picture/jvm.assets/image-20201129195619792.png)

##### 方法信息

![image-20201129195642746](picture/jvm.assets/image-20201129195642746.png)

##### 静态变量（存储在方法区上）

![image-20201129195912443](picture/jvm.assets/image-20201129195912443.png)

##### [**运行时常量池（字符串常量池存储在堆上）**]()

![image-20201129195932409](picture/jvm.assets/image-20201129195932409.png)

![image-20201129200108244](picture/jvm.assets/image-20201129200108244.png)

> [**常量池可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名，方法名，参数类型，字面量等类型。**]()

![image-20201129200506097](picture/jvm.assets/image-20201129200506097.png)

#### 方法区的演进细节

```
JDK1.6及以前：有永久代，静态变量存放在永久代上
JDK1.7：有永久代，但已经逐步“去永久化”，字符串常量池，静态变量移除，保存在堆中
JDK1.8及以后，无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池和静态变量仍在堆。
```

> 在`JDK1.7`之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时`hotspot`虚拟机对方法区的实现为永久代
>
> 在`JDK1.7` [**字符串常量池被从方法区拿到了堆**]()中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是`hotspot`中的永久代
>
> 在`JDK1.8 hotspot`移除了永久代用元空间(`Metaspace`)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(`Metaspace`) 

![image-20201129203036696](picture/jvm.assets/image-20201129203036696.png)

![image-20201129203044790](picture/jvm.assets/image-20201129203044790.png)

![image-20201129203056174](picture/jvm.assets/image-20201129203056174.png)

##### 为什么要用元空间替代永久代？

> 1. 为永久代设置空间大小是很难的
>    在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，会出现错误。
>
> 2. 对永久代调优是很困难的

##### `StringTable`为什么要调整？（及时回收内存）

![image-20201129204340553](picture/jvm.assets/image-20201129204340553.png)

##### 静态变量的存储位置？

![image-20201022153654520](file://C:/Users/sakura/Desktop/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/picture/JVM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20201022153654520.png?lastModify=1606654314)

![image-20201022153702803](file://C:/Users/sakura/Desktop/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/picture/JVM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20201022153702803.png?lastModify=1606654323)

#### 内存布局与访问定位

##### 对象内存布局

```java
public class Customer{
    int id=1001;
    String name;
    Account account;
    {
        name="匿名用户";
    }
    public Customer(){
        account=new Account();
    }
}
Class Account{
}
public class CustomerTest{
    public static void main(String[] args){
        Customer customer=new Customer();
    }
}
```

![image-20201022172844157](file://C:/Users/sakura/Desktop/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/picture/JVM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20201022172844157.png?lastModify=1606742138)

##### 对象访问定位

> 由两种方式一种是句柄访问，一种是直接指针

![image-20201130212558092](picture/jvm.assets/image-20201130212558092.png)

![image-20201130212612959](picture/jvm.assets/image-20201130212612959.png)

#### 直接内存

> 直接内存不是虚拟机运行时数据区的一部分，也不是《java虚拟机规范》中定义的内存区域。
>
> [**直接内存是java堆外的，直接向系统申请的内存区间**]()
>
> 来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存
>
> 通常访问直接内存的速度会优于java堆。即读写性能高
>
> - 出于性能考虑，读写频繁的场合可能会考虑使用直接内存
> - Java的NIO库允许Java程序使用直接内存，用于数据缓冲区

![image-20201022174352207](file://C:/Users/sakura/Desktop/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/picture/JVM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20201022174352207.png?lastModify=1606788020)

![image-20201022174801540](file://C:/Users/sakura/Desktop/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/picture/JVM%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.assets/image-20201022174801540.png?lastModify=1606788043)

```
缺点：
分配回收成本较高
不受JVM内存回收管理
配置：
直接内存大小可以通过MaxDirectMemorySize设置
如果不指定，默认与堆的最大值-Xmx参数值一致
```

# 对象的创建流程

![img](picture/jvm.assets/20190721152939242.png)

![image-20201129191555132](picture/jvm.assets/image-20201129191555132.png)

## 对象的创建步骤

**1.判断对象对应的类是否加载，链接，初始化**

> 虚拟机遇到一条new指令，首先去检查这个指令的参数能否在元空间的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。
>
> 如果没有，[**那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为KEY进行查找对应的.class文件。**]()如果没有找到文件，则抛出ClassNotFoundException异常。如果找到，则进行类加载，并生成对应的Class类对象。

**2.为对象分配内存**

> 首先[**计算对象占用空间大小**]()，接着在堆中划分一块内存给新对象。（如果该对象的实例成员变量是引用变量，仅分配引用变量空间即可，即4字节大小）
>
> 如果内存是规整的，那么虚拟机将采用的是指针碰撞法来为对象分配内存。也就是有一个指针作为已使用空间和未使用空间的分界线。分配内存只要向一侧移动与对象大小相等的一段距离就可以了。如果垃圾收集器选择的是Serial和ParNew这种基于压缩算法的，虚拟机采用这种分配方式。
>
> 如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空间列表法。虚拟机维护一个列表，记录哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。

**3.处理并发安全问题**

> 使用CAS配上失败重试保证更新的原子性。每个线程先分配一块TLAB

**4.初始化分配的空间**

> 属性的默认初始化->显式初始化/代码块中的初始化->构造器中的初始化

**5.设置对象的对象头**

> 将对象所属类的元数据信息，对象的HashCode和对象的GC信息，锁信息等数据存储在对象的对象头中。

**6.执行init方法进行初始化**

> ​    初始化成员变量，执行实例化代码块，调用类的构造器方法，并把堆内对象的首地址赋值给引用变量。

## 创建对象的方式

> 1. new（包括xxx的静态方法和xxxBuilder/xxxFactory的静态方法）
> 2. Class的newInstance()：反射的方式，[**只能调用空参的构造器，且权限必须是public**]()
> 3. Constructor的newInstance(xxx)：反射的方式，[**可以调用空参，带参构造器，权限没有要求**]()
> 4. 使用[**clone()**]()：不调用任何构造器，当前类需要实现Cloneable接口，实现clone()
> 5. 使用[**反序列化**]()：从文件，从网络中获取一个对象的二进制流

## 虚拟机类加载机制

### 概念

#### 1.类加载机制

> Java虚拟机把描述的类的数据从Class文件加载到内存，并对数据进行校验，转换，解析和初始化，最终形成可被虚拟机直接使用的java类型。

#### 2.类的生命周期

![image-20210907104526668](picture/jvm.assets/image-20210907104526668.png)

### 加载

1）操作：查找并加载类的二进制数据，生成Class的实例

1. 通过一个类的全限定类名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成这个类的Class对象，作为方法区这个类的各种数据的访问入口

2）理解

> 加载就是将Java类的字节码文件加载到内存中，并在内存中构建出Java类的原型--类模板对象。

`类模板对象`其实是Java类在JVM内存的一个快照，JVM将从字节码文件中解析出的常量池，类字段，类方法等信息存储到类模板中。这**样JVM在运行时就能通过类模板获取Java类的任意信息。`反射就基于此。`**

<img src="picture/jvm.assets/image-20201126114540528-1618147244766.png" alt="image-20201126114540528" style="zoom: 45%;" />

3）数组类的加载

`数组类本身是不由类加载器来创建的`，而是JVM在运行时，根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。

1. 如果数组的元素类型是引用类型，就正常递归加载和创建数组的元素类型
2. JVM使用指定的元素类型和数组维度来创建新的数组类

可访问性由元素类型的可访问性决定，基本数据类型为PUBLIC

### 验证

> 保证加载的字节码是否合法，合理且符合规范的

<img src="文档笔记/日常学习/复习记录/picture/jvm.assets/image-20201126120307122.png" alt="image-20201126120307122" style="zoom: 50%;" />

### 准备

> 为类的`静态变量`分[配内存，并将其初始化为默认值]()

![image-20201126120542296](picture/jvm.assets/image-20201126120542296-1618147244766.png)

注意：

- > 被标记为static final的变量不会初始化为默认值。因为这种变量在编译的时候就会分配值，在准备阶段只是显式赋值


### 解析

> 将类，接口，字段和方法的符号引用转化为直接引用（也就是得到类，字段，方法在内存中的指针或者偏移量）

符号引用就是一些字面量的引用，和虚拟机的内部数据结构和内存布局无关。

比如在Class类文件中，通过常量池进行了大量的符号引用，但是在程序实际运行时，只有符号引用往往是不够的。

​		例如当`println()`方法被调用时，系统需要明确知道该方法的位置。

![image-20201124110228495](picture/jvm.assets/image-20201124110228495-1618147244765.png)

### 初始化

> [为类的静态变量赋予正确的初始值，执行类静态成员变量赋值和静态代码块]()

**具体描述**

到了初始化阶段，才真正开始执行类中定义的java程序代码

初始化阶段的**重要工作是执行类的初始化方法：`<clinit>()`方法**

- 该方法只能由编译器生成并且由JVM调用
- 它是由类静态成员变量和静态代码块合并产生的

**说明**

- 在加载一个类之前，虚拟机总是会试图加载该类的父类，因此父类的<clinit>总是在子类的<clinit>之前被调用。

  - 也就是**由父及子，静态先行**

- 哪些类在编译成字节码后，不会包含<clinit>方法？

  - 一个类中既没有声明任何的类变量，也没有静态代码块
  - 一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化的操作
  - 一个类中包含static final修饰的基本数据类型的字段

- <clinit>方法的注意事项

  - 该方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。

  - 编译器的顺序是由语句在源文件中出现的顺序决定的。

  - 静态语句块中只能访问到定义在静态语句块之前的变量。定义在之后变量，可以赋值但是不能访问，例如

  - ```java
    public class Test{
        static{
           i=0; // 赋值可以正常通过
           System.out.println(i);// 这句编译器会提示 非法前向引用
        }
        static int i=1;
    }
    ```

### 类的主动使用

jvm不会无条件地装载class类型，只有在一个类或接口在第一次使用时，才必须要进行初始化。这里的使用，是指主动使用。

包含下列情况

```
1.当创建一个类的实例时，比如使用new关键字，或者使用反射，克隆和序列化
2.当调用类的静态方法时，即当使用了字节码invokestatic指令
3，当使用类，接口的静态字段（非final），也就是访问变量和赋值变量的操作时
4.当使用java.lang.reflect包中的方法反射类的方法时。比如Class.forName("com.zhouyi.java.Test")
5.当初始化子类时，如果发现其父类还没有初始化，则需要先触发其父类的初始化
6.如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口都要在其之前被初始化
7.当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的那个类），虚拟机会先初始化这个主类
8.当初次调用MethodHandler实例时，初始化改MethodHandle指向的方法所在的类
补充：
jvm在初始化一个类的时候需要所有父类都已经被初始化，但是初始化一个接口的时候，并不会先初始化它所实现的接口
```

### 类的被动使用

被动使用不会引起类的初始化，并不是所有类都会被初始化，只有主动使用的类才会被初始化

```
1.当访问一个静态字段时，只有真正声明这个字段的类才会被初始化
    当通过子类引用父类的静态变量，不会导致子类初始化
2.通过数组定义类引用，不会触发此类的初始化
3.引用常量不会触发此类或接口的初始化。因为常量在准备阶段就已经被显示赋值了
4.调用ClassLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化
```

### 类的卸载

一个类何时结束生命周期，取决于它的Class对象何时结束生命周期

![image-20201125101201208](picture/jvm.assets/image-20201125101201208-1618147244766.png)

#### 回收内容

- 常量池中废弃的常量：只要常量池中的常量没有被任何地方引用，就可以被回收
- 不再使用的类型：需要满足下面三个条件：
  1. 该类的所有实例都已经被回收（该类及其子类）
  2. 加载该类的类加载器已经被回收。（除非是特定场景，否则很难达成）
  3. 该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。（启动类加载器运行期间是不可能被卸载的；系统类和扩展类也不太可能被卸载，因为不能被访问到的几率太小；自定义类加载器只有在很简单的上下文环境中才能被卸载）。

综上，想要卸载一个类是非常苛刻，几乎不能达成的。

### `JAVA9`新特性

<img src="picture/jvm.assets/image-20201127121305411-1618147244767.png" alt="image-20201127121305411" style="zoom: 67%;" />

![image-20201127121242537](picture/jvm.assets/image-20201127121242537-1618147244767.png)

![image-20201127121320651](picture/jvm.assets/image-20201127121320651-1618147244767.png)

![image-20201127121330094](picture/jvm.assets/image-20201127121330094-1618147244767.png)

## 对象分配的过程

![image-20201129182213954](picture/jvm.assets/image-20201129182213954.png)

```
如果对象在Eden出生并经过第一次MinorGC后仍然能够存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1.对象在Survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定的程度（默认为15，可以调节），就会晋升到老年代。
    优先分配到老年代
    大对象直接分配到老年代
    长期存活的对象分配到老年代
```

## 什么是`TLAB`？

> [**JVM为每个线程分配了一个私有的缓存区域，包含在Eden空间内**
> **多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量。**]()
> 尽管不是所有对象实例能够在TLAB中成功分配内存，但JVM将TLAB作为内存分配的首选
> -XX:UseTLAB 设置是否开启TLAB空间
> -XX:TLABWasteTargetPercent设置TLAB空间占所有Eden空间的百分比大小。（默认为1%）
> 如果对象在TLAB空间中分配失败，JVM就会尝试通过加锁后进行分配，但是肯定就影响速度了

![image-20201129191245366](picture/jvm.assets/image-20201129191245366.png)

# 内存分配策略

## 1. 对象优先在 Eden 分配

大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。

## 2. 大对象直接进入老年代

大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。

经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。

-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。

## 3. 长期存活的对象进入老年代

为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。

-XX:MaxTenuringThreshold 用来定义年龄的阈值。

## 4. 动态对象年龄判定

[**如果在 Survivor 中相同年龄的所有对象大小的总和大于 Survivor 空间的一半**]()，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。

## 5. 空间分配担保

在发生 Minor GC 之前，虚拟机先检查老年代[**最大可用的连续空间**]()是否大于新生代所有对象总空间。

如果条件成立的话，那么 Minor GC 可以确认是安全的。

如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败

如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小

如果大于，将尝试着进行一次 Minor GC；

如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。

# 垃圾收集算法

## 1. 标记 - 清除

<img src="picture/jvm.assets/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30303562343831622d353032622d346533662d393835642d6430343363326233333061612e706e67" alt="img" style="zoom: 80%;" />

在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。

在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。

[**回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。**]()

在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。

不足：

- 标记和清除过程效率都不高；
- 会产生大量不连续的内存碎片，导致无法给大对象分配内存。

## 2. 标记 - 整理

<img src="picture/jvm.assets/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63636437373361352d616433382d343032322d383935632d3761633331386633313433372e706e67" alt="img" style="zoom: 80%;" />

让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

优点:

- 不会产生内存碎片

不足:

- 需要移动大量对象，处理效率比较低。

## 3. 复制

<img src="picture/jvm.assets/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62326237376239652d393538632d343031362d386165352d3963366564643833383731652e706e67" alt="img" style="zoom:80%;" />

将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。

主要不足是只使用了内存的一半。

现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。

HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。

## 4. 分代收集

现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。

一般将堆分为新生代和老年代。

- 新生代使用：复制算法
- 老年代使用：标记 - 清除 或者 标记 - 整理 算法

# 垃圾收集器

<img src="picture/jvm.assets/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63363235626161302d646465362d343439652d393364662d6333613637663266343330662e6a7067" alt="img" style="zoom:80%;" />

以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。

- 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；
- 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。[**除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。**]()

## 1. Serial 收集器

![img](picture/jvm.assets/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32326664613461652d346464352d343839642d616231302d3965626664616432326165302e6a7067)

Serial 翻译为串行，也就是说它以串行的方式执行。

它是单线程的收集器，只会使用一个线程进行垃圾收集工作。

[**它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。**]()

它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。

## 2. ParNew 收集器

![img](picture/jvm.assets/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38313533386364352d316263662d346533312d383665352d6531393864663165303133622e6a7067)

[**它是 Serial 收集器的多线程版本。**]()

它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。

## 3. Parallel Scavenge 收集器

![img](picture/jvm.assets/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32373866653433312d616638382d346139352d613839352d3963336238303131376465332e6a7067)

与 ParNew 一样是多线程收集器。

其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为[**“吞吐量优先”收集器**]()。这里的[**吞吐量指 CPU 用于运行用户程序的时间占总时间的比值**]()。

停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。

缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。

**可以通过一个开关参数打开 GC [自适应的调节策略]()（GC Ergonomics）**，就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以**提供最合适的停顿时间或者最大的吞吐量**。

## 4. Serial Old 收集器

![img](picture/jvm.assets/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30386633326664332d663733362d346136372d383163612d3239356232613739373266322e6a7067)

是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：

- 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。
- 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

## 5. Parallel Old 收集器

![img](picture/jvm.assets/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32373866653433312d616638382d346139352d613839352d3963336238303131376465332e6a7067)

是 Parallel Scavenge 收集器的老年代版本。

在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

## 6. CMS 收集器

![img](picture/jvm.assets/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36326537373939372d363935372d346236382d386431322d6266643630396262326336382e6a7067)

CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。

分为以下四个流程：

- 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。
- 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。
- 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
- 并发清除：不需要停顿。

在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。

具有以下缺点：

- 吞吐量低：[**低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。**]()
- 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。[**浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。**]()由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。[**如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure**]()，这时虚拟机将临时启用 Serial Old 来替代 CMS。
- [**标记 - 清除算法导致的空间碎片**]()，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。

## 7. G1 收集器

G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，[**在多 CPU 和大内存的场景下有很好的性能**]()。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。

堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。

<img src="picture/jvm.assets/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34636637313161382d376162322d343135322d623835632d6435633232363733333830372e706e67" alt="img" style="zoom:80%;" />

G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。

<img src="picture/jvm.assets/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39626264646565622d653933392d343166302d386538652d3262316130616137653061372e706e67" alt="img" style="zoom:80%;" />

通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。

> **通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。**

每个 Region 都有一个 [**Remembered Set，用来记录该 Region 对象的引用对象所在的 Region**]()。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。

![img](picture/jvm.assets/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66393965653737312d633536662d343766622d393134382d6330303336363935623566652e6a7067)

如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：

- 初始标记
- 并发标记
- 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，[**虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。**]()这阶段需要停顿线程，但是可并行执行。
- 筛选回收：[**首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。**]()此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

具备如下特点：

- **空间整合**：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。
- **可预测的停顿**：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。

# Full GC 的触发条件

对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：

## 1. 调用 System.gc()

只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。

## 2. 老年代空间不足

老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。

为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。

## 3. 空间分配担保失败

[**使用复制算法的 Minor GC 需要老年代的内存空间作担保**]()，如果担保失败会执行一次 Full GC。

## 4. JDK 1.7 及以前的永久代空间不足

在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。

当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。

为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。

## 5. Concurrent Mode Failure

执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中[**浮动垃圾过多**]()导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。

# 引用类型

无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。

Java 提供了四种强度不同的引用类型。

#### 1. 强引用

被强引用关联的对象不会被回收。

使用 new 一个新对象的方式来创建强引用。

```java
Object obj = new Object();
```

#### 2. 软引用

被软引用关联的对象只有在内存不够的情况下才会被回收。

使用 SoftReference 类来创建软引用。

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联
```

#### 3. 弱引用

被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。

使用 WeakReference 类来创建弱引用。

```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```

#### 4. 虚引用

又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。

为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。

使用 PhantomReference 来创建虚引用。

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
obj = null;
```

# ClassLoader

![image-20201125102151856](picture/jvm.assets/image-20201125102151856.png)

![image-20201125102408487](picture/jvm.assets/image-20201125102408487.png)

![image-20201125102623372](picture/jvm.assets/image-20201125102623372-16305850469821.png)

![image-20201125102722424](picture/jvm.assets/image-20201125102722424.png)

![image-20201125103204051](picture/jvm.assets/image-20201125103204051-16305850469832.png)

![image-20201125103522761](picture/jvm.assets/image-20201125103522761.png)

![image-20201125103644689](picture/jvm.assets/image-20201125103644689.png)

![image-20201125104306075](picture/jvm.assets/image-20201125104306075.png)

![image-20201125104237203](picture/jvm.assets/image-20201125104237203.png)

![image-20201125104331082](picture/jvm.assets/image-20201125104331082.png)

![image-20201125104741708](picture/jvm.assets/image-20201125104741708.png)

![image-20201125104806993](picture/jvm.assets/image-20201125104806993.png)

![image-20201125104918176](picture/jvm.assets/image-20201125104918176-16305850469833.png)

![image-20201125105144289](picture/jvm.assets/image-20201125105144289-16305850469834.png)

![image-20201125105159419](picture/jvm.assets/image-20201125105159419.png)

![image-20201125105516067](picture/jvm.assets/image-20201125105516067.png)

![image-20201125105625753](picture/jvm.assets/image-20201125105625753-16305850469836.png)

![image-20201125105741228](picture/jvm.assets/image-20201125105741228-16305850469835.png)

![image-20201125110102467](picture/jvm.assets/image-20201125110102467-16305850469838.png)

![image-20201125110120226](picture/jvm.assets/image-20201125110120226-16305850469837.png)

![image-20201125110142891](picture/jvm.assets/image-20201125110142891.png)

![image-20201125112802803](picture/jvm.assets/image-20201125112802803.png)

![image-20201125114111786](picture/jvm.assets/image-20201125114111786-16305850469839.png)

![image-20201125114205010](picture/jvm.assets/image-20201125114205010-163058504698310.png)

![image-20201125114708334](picture/jvm.assets/image-20201125114708334-163058504698411.png)

![image-20201125115408930](picture/jvm.assets/image-20201125115408930.png)

![image-20201125115559868](picture/jvm.assets/image-20201125115559868-163058504698412.png)

![image-20201125115716238](picture/jvm.assets/image-20201125115716238.png)

![image-20201125115819238](picture/jvm.assets/image-20201125115819238.png)

![image-20201125115922111](picture/jvm.assets/image-20201125115922111.png)

保护程序安全

![image-20201125120254472](picture/jvm.assets/image-20201125120254472-163058504698413.png)

![image-20201125120514143](picture/jvm.assets/image-20201125120514143.png)

![image-20201125120634882](picture/jvm.assets/image-20201125120634882.png)

![image-20201125120703331](picture/jvm.assets/image-20201125120703331.png)

![image-20201125150715972](picture/jvm.assets/image-20201125150715972.png)

![image-20201125151057289](picture/jvm.assets/image-20201125151057289.png)

![image-20201125151346127](picture/jvm.assets/image-20201125151346127.png)

![image-20201125151408193](picture/jvm.assets/image-20201125151408193.png)

![image-20201125151632612](picture/jvm.assets/image-20201125151632612.png)

![image-20201125151807015](picture/jvm.assets/image-20201125151807015.png)

![image-20201125151848244](picture/jvm.assets/image-20201125151848244.png)



![image-20201125152614993](picture/jvm.assets/image-20201125152614993.png)

![image-20201125152906533](picture/jvm.assets/image-20201125152906533.png)

![image-20201125153131646](picture/jvm.assets/image-20201125153131646.png)

![image-20201125153201483](picture/jvm.assets/image-20201125153201483.png)

![image-20201125153704589](picture/jvm.assets/image-20201125153704589-163058504698414.png)

![image-20201125153645872](picture/jvm.assets/image-20201125153645872-163058504698417.png)

![image-20201125153833449](picture/jvm.assets/image-20201125153833449-163058504698415.png)

![image-20201125160001707](picture/jvm.assets/image-20201125160001707-163058504698416.png)

![image-20201125160147359](picture/jvm.assets/image-20201125160147359.png)

![image-20201125160239916](picture/jvm.assets/image-20201125160239916.png)

![image-20201125160544651](picture/jvm.assets/image-20201125160544651.png)

![image-20201125160625169](picture/jvm.assets/image-20201125160625169.png)

![image-20201125160724771](picture/jvm.assets/image-20201125160724771.png)

不同的模块由不同的模块来加载